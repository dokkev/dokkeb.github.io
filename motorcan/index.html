<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> [CAN 04] - Gripper Motor Control with CAN Bus | Dong Ho Kang </title> <meta name="author" content="Dong Ho Kang"> <meta name="description" content="Single Motor Control with ESP32, simpleFOC, and SocketCAN for Robotic Gripper"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?968244106ed7c833589321ca0f99f9b2"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://dokkev.github.io/motorcan/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "[CAN 04] - Gripper Motor Control with CAN Bus",
            "description": "Single Motor Control with ESP32, simpleFOC, and SocketCAN for Robotic Gripper",
            "published": "December 05, 2023",
            "authors": [
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Dong Ho</span> Kang </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>[CAN 04] - Gripper Motor Control with CAN Bus</h1> <p>Single Motor Control with ESP32, simpleFOC, and SocketCAN for Robotic Gripper</p> </d-title> <d-article> <p>Previous Posts:</p> <ul> <li><a href="/aboutcan/">What is CAN?</a></li> <li><a href="/socketcan/">Setting up SocketCAN on Linux</a></li> <li><a href="/esp32can/">SocketCAN Communication with ESP32</a></li> </ul> <p><a href="http://www.youtube.com/watch?v=MmSt8G7N8ik" rel="external nofollow noopener" target="_blank">!(http://img.youtube.com/vi/MmSt8G7N8ik/0.jpg)</a></p> <div class="caption"> Optimo Manipulator Pusing and Grabbing a Jenga Block </div> <p>In the previous posts, we have achieved communicating setting up SocketCAN on Ubuntu and communicating with ESP32. In this post, we will control 1-DOF roboric girpper with ESP32 and SocketCAN using <a href="https://simplefoc.com/" rel="external nofollow noopener" target="_blank">SimpleFOC</a> Arduino library.</p> <p>This is a collaborative work <a href="https://roboligent.com/" rel="external nofollow noopener" target="_blank">Roboligent</a> with their robot manipulator, Optimo.</p> <h2 id="hardware">Hardware</h2> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/optimo-480.webp 480w,/assets/img/can/optimo-800.webp 800w,/assets/img/can/optimo-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/can/optimo.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="optimo" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/gripper-480.webp 480w,/assets/img/can/gripper-800.webp 800w,/assets/img/can/gripper-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/can/gripper.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="gripper" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Left: Optimo Arm Right: 1-DOF Robotic Gripper </div> <ul> <li><a href="https://docs.simplefoc.com/simplefocmini" rel="external nofollow noopener" target="_blank">SimpleFOC Mini</a></li> <li> <a href="https://www.aliexpress.com/i/2251832870920974.html?gatewayAdapt=4itemAdapt" rel="external nofollow noopener" target="_blank">HT2205 with AS5048A Encoder</a> Onlly used for testing not for the gripper</li> <li><a href="https://www.amazon.com/Comimark-Transceiver-TJA1050-Controller-Schnittstelle/dp/B07W4VZ2F2" rel="external nofollow noopener" target="_blank">TJA1050 CAN Transceiver</a></li> <li><a href="https://a.co/d/8sRDkUT" rel="external nofollow noopener" target="_blank">ESP32 Dev Board</a></li> <li><a href="https://makerbase3d.com/product/makerbase-canable-v2/?srsltid=AfmBOoo8SgfMBKoPkINomkXkyG8g6XlvwngQso5DAq0qLKPFEoTqkcba" rel="external nofollow noopener" target="_blank">Makerbase CANable 2.0 USB to CAN adapter</a></li> </ul> <h2 id="wiring">Wiring</h2> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/motor_wire-480.webp 480w,/assets/img/can/motor_wire-800.webp 800w,/assets/img/can/motor_wire-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/can/motor_wire.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="motor-wiring" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Wiring Diagram for Motor Control </div> <ul> <li> <p>The wiring for ESP32 and CAN Transceiver is same as the <a href="/esp32can/">previous post</a>. Some TJA1050 CAN Transceiver modules and USB-CAN deviuces include internal 120 ohm termination resistor. If you are unsure, measure the resistance between CAN-H and CAN-L wires to ensure it’s reading 60 ohm.</p> </li> <li> <p>Connect the BLDC motor’s u, v, w phases to the SimpleFOC Mini boards’ M1, M2, and M3 pins. The phase order does matter. If they are in a wrong order, the motor will not commmutate properly or run in the opposite direction. SimpleFOC Mini board will need a separate power supply. I will be providing 12 V to control HT2205 motor.</p> </li> <li> <p>Connect IN1, IN2, IN3, and EN pins to ESP32 GPIO pins while GND connects to the ground of ESP32.</p> </li> <li> <p>Supply 5V to SPI encoder and connect the SPI pins to ESP32. Most ESP32 have pre-assigned default SPI pins, but these pin assignment can be different depending on the board. You can check the default SPI pinout of your ESP32 board from the following code:</p> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void setup() {
  
  Serial.begin(115200);
  Serial.print("MOSI: ");
  Serial.println(MOSI);
  Serial.print("MISO: ");
  Serial.println(MISO);
  Serial.print("SCK: ");
  Serial.println(SCK);
  Serial.print("SS: ");
  Serial.println(SS);  
}

void loop() {
}
</code></pre></div></div> <ul> <li> <p>Make sure that there is a proper airgap between the motor magnet and the encoder if you are using magnetic encoder. The recommended airgap is usually specified in the encoder datasheet. The typical airgap for AS5048a is 1 mm airgap, but it depends on how the strength of the magnet. Improper airgap can cause noise in the signal and faulty readings.</p> </li> <li> <p>If you are trying to configue multiple SPI encoders with a shared bus (same MOSI, MISO, SCLK) but differnt chip select pins (CS), the physical wire lengths significantly affect the signal integrity. The longer the wire, the more the signal degrades. From my exerience, 3 SPI devices on the same bus with 80 MHz CLK had a maximum of 10 cm wire length. If you are using a longer wire, you may need to reduce the SPI CLK frequency. If you are 2 SPI devices, I recommend separating the SPI bus since ESP32 provides 2 SPI interfaces. You can more information <a href="https://randomnerdtutorials.com/esp32-spi-communication-arduino/" rel="external nofollow noopener" target="_blank">here</a>.</p> </li> <li> <h2 id="flashing-the-arduino-code">Flashing the Arduino Code</h2> </li> </ul> <p>Make sure to install <a href="https://docs.simplefoc.com/installation" rel="external nofollow noopener" target="_blank">SimpleFOC</a> and <a href="https://github.com/sandeepmistry/arduino-CAN" rel="external nofollow noopener" target="_blank">Arduio-CAN</a> libraries for Arduino IDE.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/diagram-480.webp 480w,/assets/img/can/diagram-800.webp 800w,/assets/img/can/diagram-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/can/diagram.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="comm-diagram" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Communication Diagram for Motor Control </div> <p>The host computer will send the desired torque command in <code class="language-plaintext highlighter-rouge">double</code> format to the ESP32 via CAN bus. The ESP32 will receive the torque command and send the current motor position in <code class="language-plaintext highlighter-rouge">double</code> back to the host computer.</p> <p>Since the CAN data can hold up to 8 bytes, we can directly encode the <code class="language-plaintext highlighter-rouge">double</code> data of torque command or motor position into the CAN data buffer with LSB order. Function such as <code class="language-plaintext highlighter-rouge">std::memcpy</code> for C++ or <code class="language-plaintext highlighter-rouge">memcpy</code> in Arduino will take care of packing the <code class="language-plaintext highlighter-rouge">double</code> data into the 1 x 8 byte buffer. However, make sure to check the endianness of the data to make sure the data is packed in LSB order.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void packDouble(double data, uint8_t *dataBuffer) {
    memcpy(dataBuffer, &amp;data, sizeof(double));
}
</code></pre></div></div> <p>Otherwise, we can directly allocate each byte of the <code class="language-plaintext highlighter-rouge">double</code> data into the CAN data buffer like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void packDouble(double data, uint8_t *dataBuffer) {
    uint64_t dataAsInt = *reinterpret_cast&lt;uint64_t*&gt;(&amp;data); // Reinterpret the double as a uint64_t
    dataBuffer[0] = (uint8_t)dataAsInt;
    dataBuffer[1] = (uint8_t)(dataAsInt &gt;&gt; 8);
    dataBuffer[2] = (uint8_t)(dataAsInt &gt;&gt; 16);
    dataBuffer[3] = (uint8_t)(dataAsInt &gt;&gt; 24);
    dataBuffer[4] = (uint8_t)(dataAsInt &gt;&gt; 32);
    dataBuffer[5] = (uint8_t)(dataAsInt &gt;&gt; 40);
    dataBuffer[6] = (uint8_t)(dataAsInt &gt;&gt; 48);
    dataBuffer[7] = (uint8_t)(dataAsInt &gt;&gt; 56);
}
</code></pre></div></div> <p>which is not clean but safe way to pack the data.</p> <details> <summary>See Arduino Code</summary> ```c++ //==================================================================================// #include <can.h> #include <simplefoc.h> #define TX_GPIO_NUM 26 // Connects to CTX #define RX_GPIO_NUM 27 // Connects to CRX #define HSPI_MISO 19 #define HSPI_MOSI 23 #define HSPI_SCLK 18 #define HSPI_SS 5 #define PWM_A 15 #define PWM_B 2 #define PWM_C 4 #define EN 16 #define CAN_RX_ID = 0x11; #define CAN_TX_ID = 0x21; #define MOTOR_POLE_PAIRS 8 #define MOTOR_PHASE_RESISTANCE 2.240 const float torque_constant = 0.0557; // Nm/A // MagneticSensorSPI(int cs, float _cpr, int _angle_register) // config - SPI config // cs - SPI chip select pin MagneticSensorSPI sensor = MagneticSensorSPI(AS5048_SPI, HSPI_SS); // for esp 32, it has 2 spi interfaces VSPI (default) and HPSI as the second one // to enable it instatiate the object SPIClass SPI_2(HSPI); BLDCMotor motor = BLDCMotor(MOTOR_POLE_PAIRS, MOTOR_PHASE_RESISTANCE); BLDCDriver3PWM driver = BLDCDriver3PWM(PWM_A, PWM_B, PWM_C, EN); Commander command = Commander(Serial); // target variable float target_torque = 0; void doTarget(char *cmd) { command.scalar(&amp;target_torque, cmd); } //==================================================================================// void setup() { Serial.begin(115200); // while (!Serial) // ; delay(1000); Serial.println("CAN Receiver/Receiver"); // Set the pins CAN.setPins(RX_GPIO_NUM, TX_GPIO_NUM); // start the CAN bus at 250 kbps if (!CAN.begin(500E3)) { Serial.println("Starting CAN failed!"); while (1) ; } else { Serial.println("CAN Initialized"); } command.add('T', doTarget, "target"); // Start Motor configMotor(); } //==================================================================================// void loop() { // user communication // command.run(); target_torque = canReceive(CAN_RX_ID); motor.loopFOC(); if (target_torque &gt; 0.5) target_torque = 0.5; else if (target_torque &lt; -0.5) target_torque = -0.5; // float target_current = target_torque / torque_constant // Nm/A motor.move(target_torque); Serial.print("target_torque: "); Serial.println(target_torque); sensor.update(); Serial.print("current position: "); Serial.println(sensor.getAngle()); // send angle over CAN } //==================================================================================// void canSender(double data) { // send packet: id is 11 bits, packet can contain up to 8 bytes of data Serial.print("Sending packet ... "); CAN.beginPacket(CAN_TX_ID ); // sets the ID and clears the transmit buffer // CAN.beginExtendedPacket(0xabcdef); // write data to buffer. data is not sent until endPacket() is // called. uint8_t dataBuffer[8]; memcpy(dataBuffer, &amp;data, sizeof(double)); CAN.write(dataBuffer, sizeof(dataBuffer)); CAN.endPacket(); Serial.print("packet end ... "); Serial.println("done"); } //==================================================================================// double canReceive(int id) { // Try to parse packet int packetSize = CAN.parsePacket(); if (packetSize) { // Received a packet if (!CAN.packetExtended() &amp;&amp; CAN.packetId() == id) { // Check if the packet size matches the expected size of a float (4 bytes) if (packetSize == sizeof(double)) { double receivedData; // Declare the received float variable // Read the 8 bytes of the double from the CAN packet and store them in // receivedData CAN.readBytes((char *)&amp;receivedData, sizeof(double)); Serial.print("Received data: "); Serial.println(receivedData); canSender(sensor.getAngle()); return receivedData; // Return the received float } } } // Return a default value (you can choose a meaningful default) return 0.0; } //==================================================================================// void configMotor() { // start the newly defined spi communication SPI_2.begin(HSPI_SCLK, HSPI_MISO, HSPI_MOSI, HSPI_SS); // SCLK, MISO, MOSI, SS // initialise magnetic sensor hardware sensor.init(&amp;SPI_2); motor.linkSensor(&amp;sensor); // Set Driver driver.voltage_power_supply = 12; driver.voltage_limit = 5; driver.init(); motor.linkDriver(&amp;driver); // FOC model selection motor.foc_modulation = FOCModulationType::SpaceVectorPWM; // set motion control loop to be used motor.controller = MotionControlType::torque; // it sends voltage without phase resistance defined // make sure to set phase resistance or current sense to command current // Set Motor Limits motor.velocity_limit = 3; motor.voltage_limit = 5; // aligning voltage motor.voltage_sensor_align = 3; // Init Motor motor.init(); motor.initFOC(); // Serial.println("Motor Init"); } //==================================================================================// ``` &lt;/details&gt; When a command is recived from the host computer, the ESP32 will send command current to motor by converting the torque command to current command with pre-defiend torque constant and respond with the motor position to the host computer. We can implement a simple [C++ code to read and write over SocketCAN](https://blog.mbedded.ninja/programming/operating-systems/linux/how-to-use-socketcan-with-c-in-linux/) to control the motor. [![Video](http://img.youtube.com/vi/8PiBqahbf7M/0.jpg)](http://www.youtube.com/watch?v=8PiBqahbf7M) <div class="caption"> Motor Cotnrol with SocketCAN. In the video, I only sent float data in ESP32 and received the same float data back from ESP32 instead of double. In this case, the CAN data buffer is 4 bytes instead of 8 bytes. </div> Now we can control the gripper motor using the same setup. Using the linear motion of the belt, we can achieve parallel gripper motion. The belt is connected to the motor shaft and the gripper jaws. When the motor rotates, the belt moves the jaws in the opposite direction. <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/can/gripper_mech-480.webp 480w,/assets/img/can/gripper_mech-800.webp 800w,/assets/img/can/gripper_mech-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/can/gripper_mech.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="gripper_mech" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Mechanism for the Parallel Gripper with one motor </div> We recorded the joint trajectories including the gripper motor to push the jenga piece and grab it by kinestheic teaching (manually driving the robot). We can use the recorded joint trajectories to replay the same motion. [![Video](http://img.youtube.com/vi/MmSt8G7N8ik/0.jpg)](http://www.youtube.com/watch?v=MmSt8G7N8ik) <div class="caption"> Optimo Manipulator Pusing and Grabbing a Jenga Block </div> </simplefoc.h></can.h></details> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Dong Ho Kang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: November 13, 2024. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-publications",title:"publications",description:"publications by categories in reversed chronological order. generated by jekyll-scholar.",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"nav-projects",title:"projects",description:"Robotics Portfolio",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-cv",title:"cv",description:"",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"post-resources-for-learning-robotics",title:"Resources for Learning Robotics",description:"Collection of useful resources for learning robotics.",section:"Posts",handler:()=>{window.location.href="/Intro-to-Robotics/"}},{id:"post-can-04-gripper-motor-control-with-can-bus",title:"[CAN 04] - Gripper Motor Control with CAN Bus",description:"Single Motor Control with ESP32, simpleFOC, and SocketCAN for Robotic Gripper",section:"Posts",handler:()=>{window.location.href="/motorcan/"}},{id:"post-can-03-communicating-to-esp32-with-socketcan",title:"[CAN 03] - Communicating to ESP32 with SocketCAN",description:"SocketCAN Communication with ESP32",section:"Posts",handler:()=>{window.location.href="/esp32can/"}},{id:"post-can-02-setting-up-socketcan-on-linux",title:"[CAN 02] - Setting up SocketCAN on Linux",description:"Setting up SocketCAN",section:"Posts",handler:()=>{window.location.href="/socketcan/"}},{id:"post-can-01-what-is-can",title:"[CAN 01] - What is CAN?",description:"What is CAN Bus and how is it used in robotics?",section:"Posts",handler:()=>{window.location.href="/aboutcan/"}},{id:"news-our-paper-rpc-a-modular-framework-for-robot-planning-control-and-deployment-https-arxiv-org-abs-2409-10015-has-been-accepted-to-the-2025-ieee-sice-international-symposium-on-system-integration-sii",title:"Our paper [RPC: A Modular Framework for Robot Planning, Control, and Deployment](https://arxiv.org/abs/2409.10015) has...",description:"",section:"News"},{id:"projects-cup-tower-stacking-with-baxter",title:"Cup Tower Stacking with Baxter",description:"Baxter stacks tower of cups with Moveit, Apriltag, and OpenCV",section:"Projects",handler:()=>{window.location.href="/projects/baxter-tower/"}},{id:"projects-bldc-motor-control-with-pid-controller",title:"BLDC Motor Control with PID Controller",description:"BLDC Motor Control with NU32 micrcontroller and DRV8835 H-bridge motor driver",section:"Projects",handler:()=>{window.location.href="/projects/motor/"}},{id:"projects-autonomous-fire-fighting-robot",title:"Autonomous Fire Fighting Robot",description:"Sensing and Localization of Fire, Grasping, and Operating Fire Extinguisher",section:"Projects",handler:()=>{window.location.href="/projects/firefigther/"}},{id:"projects-progamming-pic32-with-c",title:"Progamming PIC32 with C",description:"UART, SPI, LCD, LED, IMU, and more",section:"Projects",handler:()=>{window.location.href="/projects/PIC32/"}},{id:"projects-impact-modeling-with-euler-lagrangian-and-hamiltonian-mechanics",title:"Impact Modeling with Euler-Lagrangian and Hamiltonian Mechanics",description:"4 point mass system impact simulation in Python with SymPy",section:"Projects",handler:()=>{window.location.href="/projects/impact/"}},{id:"projects-whisker-based-tactile-sensing-and-shape-classification",title:"Whisker-based Tactile Sensing and Shape Classification",description:"active vibrissal sensing to classify concave and convex objects using ANN and invtestigation in the transformation from the whisker base frame to the head frame using RL",section:"Projects",handler:()=>{window.location.href="/projects/whisker-tactile/"}},{id:"projects-humanoid-robot-control-with-pypnc",title:"Humanoid Robot Control with PyPnC",description:"Whole Body Control and DCM Planner based Locomotion in PyBullet",section:"Projects",handler:()=>{window.location.href="/projects/pypnc/"}},{id:"projects-proprioceptive-robotic-hand-design-and-control",title:"Proprioceptive Robotic Hand Design and Control",description:"Five-bar linkages multi-dof robotic hand design and impedance control",section:"Projects",handler:()=>{window.location.href="/projects/platov2/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%64%6F%6E%67%68%6F@%75%74%65%78%61%73.%65%64%75","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=YlYSer0AAAAJ","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/dokkev","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>