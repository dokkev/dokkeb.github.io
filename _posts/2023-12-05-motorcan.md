---
title: "[CAN 04] - Gripper Motor Control with CAN Bus"
description: Single Motor Control with ESP32, simpleFOC, and SocketCAN for Robotic Gripper
layout: distill
published: true
date: 2023-12-05 00:00:00
img: /assets/img/can/socketcan.jpg
permalink: /motorcan/
tags: [Hardware Development,Robotic Manipulation]
# categories: robotics101

---

Previous Posts:
- [What is CAN?](/aboutcan/)
- [Setting up SocketCAN on Linux](/socketcan/)
- [SocketCAN Communication with ESP32](/esp32can/)


<div class="row">
    <div class="col-sm mt-3 mt-md-0">
        [![1](http://img.youtube.com/vi/MmSt8G7N8ik/0.jpg)](http://www.youtube.com/watch?v=MmSt8G7N8ik)
    </div>
</div>
<div class="caption">
   Optimo Manipulator Pusing and Grabbing a Jenga Block
</div>

In the previous posts, we have achieved communicating setting up SocketCAN on Ubuntu and communicating with ESP32. In this post, we will control 1-DOF roboric girpper with ESP32 and SocketCAN using [SimpleFOC](https://simplefoc.com/) Arduino library.

This is a collaborative work [Roboligent](https://roboligent.com/) with their robot manipulator, Optimo.

## Hardware

<div class="row">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/can/optimo.jpg" title="optimo" class="img-fluid rounded z-depth-1" %}
    </div>
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/can/gripper.jpg" title="gripper" class="img-fluid rounded z-depth-1" %}
    </div>
</div>
<div class="caption">
  Left: Optimo Arm Right: 1-DOF Robotic Gripper
</div>

- [SimpleFOC Mini](https://docs.simplefoc.com/simplefocmini)
- [HT2205 with AS5048A Encoder](https://www.aliexpress.com/i/2251832870920974.html?gatewayAdapt=4itemAdapt) Onlly used for testing not for the gripper
- [TJA1050 CAN Transceiver](https://www.amazon.com/Comimark-Transceiver-TJA1050-Controller-Schnittstelle/dp/B07W4VZ2F2)
- [ESP32 Dev Board](https://a.co/d/8sRDkUT)
- [Makerbase CANable 2.0 USB to CAN adapter](https://makerbase3d.com/product/makerbase-canable-v2/?srsltid=AfmBOoo8SgfMBKoPkINomkXkyG8g6XlvwngQso5DAq0qLKPFEoTqkcba)



## Wiring
<div class="row">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/can/motor-wire.jpg" title="motor-wiring" class="img-fluid rounded z-depth-1" %}
    </div>
</div>
<div class="caption">
 Wiring Diagram for Motor Control
</div>

- The wiring for ESP32 and CAN Transceiver is same as the [previous post](/esp32can/). Some TJA1050 CAN Transceiver modules and USB-CAN deviuces include internal 120 ohm termination resistor. If you are unsure, measure the resistance between CAN-H and CAN-L wires to ensure it's reading 60 ohm.

- Connect the BLDC motor's u, v, w phases to the SimpleFOC Mini boards' M1, M2, and M3 pins. The phase order does matter. If they are in a wrong order, the motor will not commmutate properly or run in the opposite direction. SimpleFOC Mini board will need a separate power supply. I will be providing 12 V to control HT2205 motor. 

- Connect IN1, IN2, IN3, and EN pins to ESP32 GPIO pins while GND connects to the ground of ESP32.

- Supply 5V to SPI encoder and connect the SPI pins to ESP32. Most ESP32 have pre-assigned default SPI pins, but these pin assignment can be different depending on the board. You can check the default SPI pinout of your ESP32 board from the following code
```
void setup() {
  
  Serial.begin(115200);
  Serial.print("MOSI: ");
  Serial.println(MOSI);
  Serial.print("MISO: ");
  Serial.println(MISO);
  Serial.print("SCK: ");
  Serial.println(SCK);
  Serial.print("SS: ");
  Serial.println(SS);  
}

void loop() {
}
```


- Make sure that there is a proper airgap between the motor magnet and the encoder if you are using magnetic encoder. The recommended airgap is usually specified in the encoder datasheet. The typical airgap for AS5048a is 1 mm airgap, but it depends on how the strength of the magnet. Improper airgap can cause noise in the signal and faulty readings.

- If you are trying to configue multiple SPI encoders with a shared bus (same MOSI, MISO, SCLK) but differnt chip select pins (CS), the physical wire lengths significantly affect the signal integrity. The longer the wire, the more the signal degrades. From my exerience, 3 SPI devices on the same bus with 80 MHz CLK had a maximum of 10 cm wire length. If you are using a longer wire, you may need to reduce the SPI CLK frequency. If you are 2 SPI devices, I recommend separating the SPI bus since ESP32 provides 2 SPI interfaces. You can more information [here](https://randomnerdtutorials.com/esp32-spi-communication-arduino/).

- 
## Flashing the Arduino Code

Make sure to install [SimpleFOC](https://docs.simplefoc.com/installation) and [Arduio-CAN](https://github.com/sandeepmistry/arduino-CAN) libraries for Arduino IDE. 

<div class="row">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/can/diagram.jpg" title="comm-diagram" class="img-fluid rounded z-depth-1" %}
    </div>
</div>
<div class="caption">
 Communication Diagram for Motor Control
</div>

The host computer will send the desired torque command in `double` format to the ESP32 via CAN bus. The ESP32 will receive the torque command and send the current motor position in `double` back to the host computer.

Since the CAN data can hold up to 8 bytes, we can directly encode the `double` data of torque command or motor position into the CAN data buffer with LSB order. Function such as `std::memcpy` for C++ or `memcpy` in Arduino will take care of packing the `double` data into the 1 x 8 byte buffer. However, make sure to check the endianness of the data to make sure the data is packed in LSB order.
```
void packDouble(double data, uint8_t *dataBuffer) {
    memcpy(dataBuffer, &data, sizeof(double));
}
```

Otherwise, we can directly allocate each byte of the `double` data into the CAN data buffer like this:
```
void packDouble(double data, uint8_t *dataBuffer) {
    uint64_t dataAsInt = *reinterpret_cast<uint64_t*>(&data); // Reinterpret the double as a uint64_t
    dataBuffer[0] = (uint8_t)dataAsInt;
    dataBuffer[1] = (uint8_t)(dataAsInt >> 8);
    dataBuffer[2] = (uint8_t)(dataAsInt >> 16);
    dataBuffer[3] = (uint8_t)(dataAsInt >> 24);
    dataBuffer[4] = (uint8_t)(dataAsInt >> 32);
    dataBuffer[5] = (uint8_t)(dataAsInt >> 40);
    dataBuffer[6] = (uint8_t)(dataAsInt >> 48);
    dataBuffer[7] = (uint8_t)(dataAsInt >> 56);
}
```
which is not clean but safe way to pack the data.


<details>
  <summary>See Arduino Code</summary>

```
//==================================================================================//

#include <CAN.h>
#include <SimpleFOC.h>

#define TX_GPIO_NUM 26 // Connects to CTX
#define RX_GPIO_NUM 27 // Connects to CRX

#define HSPI_MISO 19
#define HSPI_MOSI 23
#define HSPI_SCLK 18
#define HSPI_SS 5

#define PWM_A 15
#define PWM_B 2
#define PWM_C 4
#define EN 16

#define CAN_RX_ID = 0x11;
#define CAN_TX_ID = 0x21;

#define MOTOR_POLE_PAIRS 8
#define MOTOR_PHASE_RESISTANCE 2.240

const float torque_constant = 0.0557; // Nm/A


// MagneticSensorSPI(int cs, float _cpr, int _angle_register)
// config           - SPI config
//  cs              - SPI chip select pin
MagneticSensorSPI sensor = MagneticSensorSPI(AS5048_SPI, HSPI_SS);

// for esp 32, it has 2 spi interfaces VSPI (default) and HPSI as the second one
// to enable it instatiate the object
SPIClass SPI_2(HSPI);

BLDCMotor motor = BLDCMotor(MOTOR_POLE_PAIRS, MOTOR_PHASE_RESISTANCE);
BLDCDriver3PWM driver = BLDCDriver3PWM(PWM_A, PWM_B, PWM_C, EN);
Commander command = Commander(Serial);
// target variable
float target_torque = 0;
void doTarget(char *cmd) { command.scalar(&target_torque, cmd); }


//==================================================================================//

void setup() {
  Serial.begin(115200);
  // while (!Serial)
  //   ;
  delay(1000);

  Serial.println("CAN Receiver/Receiver");

  // Set the pins
  CAN.setPins(RX_GPIO_NUM, TX_GPIO_NUM);

  // start the CAN bus at 250 kbps
  if (!CAN.begin(500E3)) {
    Serial.println("Starting CAN failed!");
    while (1)
      ;
  } else {
    Serial.println("CAN Initialized");
  }

  command.add('T', doTarget, "target");
  // Start Motor
  configMotor();
}

//==================================================================================//

void loop() {
  // user communication
  // command.run();

  target_torque = canReceive(CAN_RX_ID);

  motor.loopFOC();

  if (target_torque > 0.5)
    target_torque = 0.5;
  else if (target_torque < -0.5)
    target_torque = -0.5;

  // float target_current = target_torque / torque_constant // Nm/A
  motor.move(target_torque);
  Serial.print("target_torque: ");
  Serial.println(target_torque);

  sensor.update();
  Serial.print("current position: ");
  Serial.println(sensor.getAngle());
  // send angle over CAN
  
}

//==================================================================================//

void canSender(double data) {

  // send packet: id is 11 bits, packet can contain up to 8 bytes of data
  Serial.print("Sending packet ... ");

  CAN.beginPacket(CAN_TX_ID ); // sets the ID and clears the transmit buffer
  // CAN.beginExtendedPacket(0xabcdef);
  // write data to buffer. data is not sent until endPacket() is
  // called.
  uint8_t dataBuffer[8];
  memcpy(dataBuffer, &data, sizeof(double));
  CAN.write(dataBuffer, sizeof(dataBuffer));
  CAN.endPacket();
  Serial.print("packet end ... ");


  Serial.println("done");
}


//==================================================================================//

double canReceive(int id) {
  // Try to parse packet
  int packetSize = CAN.parsePacket();

  if (packetSize) {
    // Received a packet
    if (!CAN.packetExtended() && CAN.packetId() == id) {
      // Check if the packet size matches the expected size of a float (4 bytes)
      if (packetSize == sizeof(double)) {
        double receivedData; // Declare the received float variable

        // Read the 8 bytes of the double from the CAN packet and store them in
        // receivedData
        CAN.readBytes((char *)&receivedData, sizeof(double));
        Serial.print("Received data: ");
        Serial.println(receivedData);
        canSender(sensor.getAngle());
        return receivedData; // Return the received float
      }
    }
  }

  // Return a default value (you can choose a meaningful default)
  return 0.0;
}

//==================================================================================//

void configMotor() {
  // start the newly defined spi communication
  SPI_2.begin(HSPI_SCLK, HSPI_MISO, HSPI_MOSI, HSPI_SS); // SCLK, MISO, MOSI, SS
  // initialise magnetic sensor hardware
  sensor.init(&SPI_2);
  motor.linkSensor(&sensor);

  // Set Driver
  driver.voltage_power_supply = 12;
  driver.voltage_limit = 5;
  driver.init();
  motor.linkDriver(&driver);

  // FOC model selection
  motor.foc_modulation = FOCModulationType::SpaceVectorPWM;
  // set motion control loop to be used
  motor.controller = MotionControlType::torque; // it sends voltage without phase resistance defined
                                                // make sure to set phase resistance or current sense to command current

  // Set Motor Limits
  motor.velocity_limit = 3;
  motor.voltage_limit = 5;

  // aligning voltage
  motor.voltage_sensor_align = 3;

  // Init Motor
  motor.init();
  motor.initFOC();

  // Serial.println("Motor Init");
}

//==================================================================================//

```
</details>